# 단위테스트(UnitTest)

~~~text
단위 테스트는 응용 프로그램에서 테스트 가능한 가장 작은 소프트웨어를 실행하여 예상대로 동작하는지 확인하는 테스트이다.
~~~
- 단위 테스트의 `테스트 대상 단위의 크기`는 엄격하게 정해져 있지 않음
- 일반적으로 `하나의 기능` 또는 `메서드` 수준
- 단위의 크기가 `작을수록` 단위의 `복잡성`이 낮아짐
## 단위테스트 필요성
- 특정 부분만 `독립적`으로 테스트하기 때문에 어떤 코드를 리팩토링하여도 빠르게 문제 여부 확인 가능
- 테스팅에 대한 시간과 비용을 절감 가능
- 새로운 기능 추가 시에 수시로 빠르게 테스트 가능
- `리팩토링` 시에 `안정성`을 확보
- 코드에 대한 문서가 될 수 있음
## 좋은 단위 테스트 특징(from Clean Code)
- 변경된 코드를 검증할 수 있어야 함
- 1개의 테스트 함수는 1가지 개념 만을 테스트하라
- 1개의 테스트 함수에 대해 assert를 최소화하라  
`First`
- Fast: 테스트는 `빠르게 동작`하여 자주 돌릴 수 있어야 한다.
- Independent: 각각의 테스트는 `독립적`이며 서로 의존해서는 안된다.
- Repeatable: `어느 환경`에서도 `반복` 가능해야 한다.
- Self-Validating: 테스트는 `성공` 또는 `실패`로 `bool` 값으로 결과를 내어 자체적으로 검증되어야 한다.
- Timely: 테스트는 적시에 즉, 테스트하려는 `실제 코드를 구현하기 직전`에 구현해야 한다.

---
## 작성준비 - 필요한 라이브러리
~~~
최근 Java 단위테스트 작성에는 크게 2가지 라이브러리가 사용

- JUnit5: 자바 단위 테스트를 위한 테스팅 프레임워크
- AssertJ: 자바 테스트를 돕기 위해 다양한 문법을 지원하는 라이브러리(ssertEquals()와 같은 메소드 사용)
~~~

## 작성준비 - given/when/then 패턴
~~~
given-when-then 패턴이 필수는 아니지만, 대부분 사용하는 패턴이므로 소개한다.
 - given(준비): 테스트에 필요한 데이터가 준비되었을 때
 - when(실행): 테스트의 목적 행위(메서드)를 실행하면
 - then(검증): 예상한 결과가 나와야 한다.
~~~

## 작성준비 - 테스트코드 예시
~~~java
    @Test
    @DisplayName("양끝 문자열 제거")
    public void 문자열_제거() {
        // given
        String str = "(1,2)";
        //  when
        str = str.substring(1, str.length() - 1);
        // then
        assertThat(str).isEqualTo("1,2");
    }
~~~

## 코드 예시 확인

---

## Mockito 사용
- 개발자가 동작을 직접 제어할 수 있는 `가짜객체`(Mock)를 지원하는 테스트 프레임워크
- 여러 객체들 간의 의존이 생겨 단위 테스트 작성의 어려움을 해결하기 위해 사용
- `Mock을 하지 않아도 된다면, 안하는 것이 가장 좋음`

## Mockito 사용 - Mock객체의 의존성 주입
- `@Mock`: Mock 객체를 만들어 반환해주는 어노테이션
- `@Spy`: Stub하지 않은 메소드들은 원본 메소드 그대로 사용하는 어노테이션
- `@InjectMocks`: `@Mock` 또는 `@Spy`로 생성된 가짜 객체를 자동으로 주입시켜주는 어노테이션

## Mockito 사용 - Stub 활용
### Stub
- 서비스 연관 객체 대신 `가짜 객체(MockObject)`를 주입하여 `정해진 답변`을 준비하는 것
- 애플리케이션은 `객체`간의 `메세지`를 주고 받아야 함
- `단위테스트`는 모듈에 대한 독립적인 테스트이기 때문에 다른 객체와 `메세지`를 주고 받는 상황엔 문제가 발생 -> Mock Object 사용
### Stub 메서드 활용하여 결과처리
- doReturn(): Mock 객체가 특정한 값을 반환해야 하는 경우
- doNothing(): Mock 객체가 아무 것도 반환하지 않는 경우(void)
- doThrow(): Mock 객체가 예외를 발생시키는 경우
## Mockito 사용 - Junit 결합
- Mockito도 `테스팅 프레임워크`이기 때문에 JUnit과 겷합하기 위해 작업 필요 
- `@ExtendWith(MockitoExtension.class)` 적용해야 결합 가능
~~~java
@ExtendWith(MockitoExtension.class)
class UserControllerTest {

}
~~~

## 코드 예시 확인

## 통합테스트(Intergration Test)
~~~text
통합 테스트는 단위 테스트보다 더 큰 동작을 달성하기 위해 여러 모듈들을 모아 이들이 의도대로 협력하는지 확인하는 테스트이다.
~~~
- 개발자가 변경할 수 없는 부분(ex.라이브러리)까지 묶어서 검증할 때 사용
- `DB에 접근`하거나 전체 코드와 다양한 환경이 `전체적으로 제대로 작동`하는지 확인하는데 필요한 모든 작업을 수행
- 단점은 많은 코드를 테스트하기 때문에 어디서 에러가 발생했는지 확인하기 쉽지 않아 유지보수에 대한 이슈가 있음
- `@SpringBootTest` 어노테이션을 붙여 통합테스트 수행
~~~java
@SpringBootTest
Class ApplicationTests {
    
    @Test
    void contextLoads() {
    }
}
~~~

## 인수테스트(Acceptance Test)
~~~text
인수 테스트는 사용자 스토리(시나리오)에 맞춰 수행하는 테스트이다.
~~~
- 단위테스트 통합테스트와 달리 `비즈니스`쪽에 초점을 두어 작성
- 프로젝트에 참여자(기획자, 개발자 등)들 간의 토의해서 나온 `시나리오(Scenario)` 기반
- 다른 의사소통집단으로투벝 시나리오를 받아(인수) 개발 한다는 의미
- 시나리오의 요구사항: `누가`, `어떤 목적으로`, `무엇을 하는가` 
- `RestAssured`, `MockMvc` 활용
## 예시 코드 확인

## 참조
- https://tecoble.techcourse.co.kr/post/2021-05-25-unit-test-vs-integration-test-vs-acceptance-test/
- https://mangkyu.tistory.com/144
